drop table comm cascade constraints;
create table comm(
 num		number			primary key,
 id			varchar2(30)	references member(id),
 content	varchar2(200),
 reg_date	date,
 comment_board_num	number	references	RVB(RV_NO) on delete cascade,
 												-- comm 테이블이 참조하는 보드 글 번호
 comment_re_lev number(1) check(comment_re_lev in (0,1,2)), --원문이면 0 답글이면 1
 comment_re_seq number, --원문이면 0 
 comment_re_ref number -- 원문은 자신 글번호 , 답글이면 원문 글번호
);
-- 게시판 글이 삭제되면 참조하는 댓글도 삭제됩니다. --

drop sequence com_seq;

-- 시퀀스를 생성합니다.
create sequence com_seq;

select * from comm;

update comm 
set id= 'ADMIN' ;

UPDATE MEMBER
SET ID = 'ADMIN'

SELECT * FROM MEMBER;

delete comm;

-- member에 있는 memberfile까지 조회해 봅시다.
select comm.*, member.memberfile
from comm inner join member
on comm.id=member.id
where comment_board_num = 13
order by comment_re_ref desc ,
comment_re_seq asc ;



drop table comm cascade constraints;
create table comm(
 num		number			primary key,
 id			varchar2(30)	references member(id),
 content	varchar2(200),
 reg_date	date,
 comment_board_num	number	references	RVB(RV_NO) on delete cascade,
 												-- comm 테이블이 참조하는 보드 글 번호
 comment_re_lev number(1) check(comment_re_lev in (0,1,2)), --원문이면 0 답글이면 1
 comment_re_seq number, --원문이면 0 
 comment_re_ref number -- 원문은 자신 글번호 , 답글이면 원문 글번호
);
-- 게시판 글이 삭제되면 참조하는 댓글도 삭제됩니다. --

drop sequence com_seq;

-- 시퀀스를 생성합니다.
create sequence com_seq;

select * from comm;

update comm 
set id= 'ADMIN' ;

UPDATE MEMBER
SET ID = 'ADMIN'

SELECT * FROM MEMBER;

delete comm;

-- member에 있는 memberfile까지 조회해 봅시다.
select comm.*, member.memberfile
from comm inner join member
on comm.id=member.id
where comment_board_num = 13
order by comment_re_ref desc ,
comment_re_seq asc ;
